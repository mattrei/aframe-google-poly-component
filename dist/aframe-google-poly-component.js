(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global AFRAME */\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\nconst POLY_API_URL = 'https://poly.googleapis.com/v1/assets/';\n\n__webpack_require__(/*! ./lib/LegacyGLTFLoader */ \"./lib/LegacyGLTFLoader.js\");\n/**\n * Google Poly component for A-Frame.\n */\n\n\nAFRAME.registerComponent('google-poly', {\n  schema: {\n    apiKey: {\n      default: ''\n    },\n    src: {},\n    normalize: {\n      type: 'boolean',\n      default: true\n    }\n  },\n  multiple: false,\n  init: function () {\n    this.model = null;\n  },\n  update: function (oldData) {\n    const el = this.el;\n    const data = this.data;\n    if (!data.src || !data.apiKey) return;\n    this.remove();\n    this.getGLTFUrl(data.src, data.apiKey).then(this.loadPolyModel).then(gltfModel => {\n      this.model = gltfModel.scene || gltfModel.scenes[0];\n      this.model.animations = gltfModel.animations;\n      el.setObject3D('mesh', this.model); //el.emit('model-loaded', {format: 'gltf', model: this.model})\n\n      if (data.normalize) {\n        this.normalize();\n      }\n\n      el.emit('model-loaded');\n    }).catch(err => {\n      console.error('ERROR loading Google Poly model from \"' + data.src + '\" : ' + err);\n      el.emit('model-error', err);\n    });\n  },\n  normalize: function () {\n    const el = this.el;\n    const mesh = el.getObject3D('mesh');\n    const span = 1;\n    const offset = new THREE.Vector3(); // data.offset?\n\n    const position = new THREE.Vector3();\n    const scale = new THREE.Vector3();\n    position.copy(el.object3D.position);\n    scale.copy(el.object3D.scale);\n    el.object3D.scale.set(1, 1, 1);\n    el.object3D.position.set(0, 0, 0);\n    el.object3D.updateMatrixWorld(true); // https://github.com/mrdoob/three.js/blob/master/src/core/Geometry.js#L367\n\n    const box = new THREE.Box3();\n    box.setFromObject(mesh);\n    const boundingSphere = new THREE.Sphere();\n    box.getBoundingSphere(boundingSphere);\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n    const s = (radius === 0 ? 1 : 1.0 / radius) * span;\n    mesh.traverse(child => {\n      if (child.isMesh) {\n        child.geometry.scale(s, s, s);\n        child.geometry.translate(-s * center.x + offset.x, -s * center.y + offset.y, -s * center.z + offset.z);\n        child.geometry.computeBoundingBox();\n        child.geometry.computeBoundingSphere();\n      }\n    });\n    el.object3D.scale.copy(scale);\n    el.object3D.position.copy(position);\n    el.object3D.updateMatrixWorld(true);\n  },\n  _remove: function () {\n    if (this.model) this.el.removeObject3D('mesh');\n  },\n  remove: function () {\n    this._remove();\n  },\n  getGLTFUrl: function (id, apiKey) {\n    const url = POLY_API_URL + id + '/?key=' + apiKey;\n    return fetch(url).then(function (response) {\n      // parse response\n      return response.json().catch(error => {\n        // handle JSON parsing error\n        console.log('ERROR parsing Google Poly API server response JSON.\\nRequested Model: \"' + url + '\"\\nError: \"' + JSON.stringify(error) + '\"');\n        return Promise.reject('Google Poly API server error. Check console for details.');\n      }).then(info => {\n        if (info.error !== undefined) {\n          return Promise.reject('Poly API error: ' + info.error.message);\n        }\n\n        const format = info.formats.find(format => format.formatType === 'GLTF' || format.formatType === 'GLTF2');\n\n        if (format) {\n          const r = info.presentationParams.orientingRotation;\n          const quaternion = new THREE.Quaternion(r.x || 0, r.y || 0, r.z || 0, r.w || 1);\n          return {\n            url: format.root.url,\n            quaternion: quaternion,\n            format: format.formatType\n          };\n        } else {\n          return Promise.reject('Poly asset id:' + id + ' not provided in GLTF or GLTF2 format.');\n        }\n      });\n    });\n  },\n  loadPolyModel: function (data, onProgress) {\n    const url = data.url;\n    const quaternion = data.quaternion;\n    const format = data.format;\n    const matrix = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);\n    return new Promise((resolve, reject) => {\n      const loader = new THREE.FileLoader();\n      loader.setResponseType('arraybuffer');\n      loader.load(url, data => {\n        try {\n          console.log('loading', url, format);\n          const gltfLoader = format === 'GLTF' ? new THREE.LegacyGLTFLoader() : new THREE.GLTFLoader();\n          const path = THREE.LoaderUtils.extractUrlBase(url);\n          gltfLoader.parse(data, path, gltf => {\n            gltf.scene.traverse(function (child) {\n              if (format === 'GLTF' && child.material) child.material = new THREE.MeshStandardMaterial({\n                vertexColors: THREE.VertexColors\n              });\n              if (child.geometry) child.geometry.applyMatrix(matrix);\n            });\n            resolve(gltf);\n          }, reject);\n        } catch (e) {\n          console.error(e); // For SyntaxError or TypeError, return a generic failure message.\n\n          reject(e.constructor === Error ? e : new Error('THREE.GLTFLoader: Unable to parse model.'));\n        }\n      }, onProgress, reject);\n    });\n  }\n});\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./lib/LegacyGLTFLoader.js":
/*!*********************************!*\
  !*** ./lib/LegacyGLTFLoader.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n */\nTHREE.LegacyGLTFLoader = function () {\n  function LegacyGLTFLoader(manager) {\n    THREE.Loader.call(this, manager);\n  }\n\n  LegacyGLTFLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {\n    constructor: LegacyGLTFLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      var scope = this;\n      var resourcePath;\n\n      if (this.resourcePath !== '') {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== '') {\n        resourcePath = this.path;\n      } else {\n        resourcePath = THREE.LoaderUtils.extractUrlBase(url);\n      }\n\n      var loader = new THREE.FileLoader(scope.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (data) {\n        scope.parse(data, resourcePath, onLoad);\n      }, onProgress, onError);\n    },\n    parse: function (data, path, callback) {\n      var content;\n      var extensions = {};\n      var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n      if (magic === BINARY_EXTENSION_HEADER_DEFAULTS.magic) {\n        extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n      } else {\n        content = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n      }\n\n      var json = JSON.parse(content);\n\n      if (json.extensionsUsed && json.extensionsUsed.indexOf(EXTENSIONS.KHR_MATERIALS_COMMON) >= 0) {\n        extensions[EXTENSIONS.KHR_MATERIALS_COMMON] = new GLTFMaterialsCommonExtension(json);\n      }\n\n      var parser = new GLTFParser(json, extensions, {\n        crossOrigin: this.crossOrigin,\n        manager: this.manager,\n        path: path || this.resourcePath || ''\n      });\n      parser.parse(function (scene, scenes, cameras, animations) {\n        var glTF = {\n          \"scene\": scene,\n          \"scenes\": scenes,\n          \"cameras\": cameras,\n          \"animations\": animations\n        };\n        callback(glTF);\n      });\n    }\n  });\n  /* GLTFREGISTRY */\n\n  function GLTFRegistry() {\n    var objects = {};\n    return {\n      get: function (key) {\n        return objects[key];\n      },\n      add: function (key, object) {\n        objects[key] = object;\n      },\n      remove: function (key) {\n        delete objects[key];\n      },\n      removeAll: function () {\n        objects = {};\n      },\n      update: function (scene, camera) {\n        for (var name in objects) {\n          var object = objects[name];\n\n          if (object.update) {\n            object.update(scene, camera);\n          }\n        }\n      }\n    };\n  }\n  /* GLTFSHADERS */\n\n\n  LegacyGLTFLoader.Shaders = {\n    update: function () {\n      console.warn('THREE.LegacyGLTFLoader.Shaders has been deprecated, and now updates automatically.');\n    }\n  };\n  /* GLTFSHADER */\n\n  function GLTFShader(targetNode, allNodes) {\n    var boundUniforms = {}; // bind each uniform to its source node\n\n    var uniforms = targetNode.material.uniforms;\n\n    for (var uniformId in uniforms) {\n      var uniform = uniforms[uniformId];\n\n      if (uniform.semantic) {\n        var sourceNodeRef = uniform.node;\n        var sourceNode = targetNode;\n\n        if (sourceNodeRef) {\n          sourceNode = allNodes[sourceNodeRef];\n        }\n\n        boundUniforms[uniformId] = {\n          semantic: uniform.semantic,\n          sourceNode: sourceNode,\n          targetNode: targetNode,\n          uniform: uniform\n        };\n      }\n    }\n\n    this.boundUniforms = boundUniforms;\n    this._m4 = new THREE.Matrix4();\n  } // Update - update all the uniform values\n\n\n  GLTFShader.prototype.update = function (scene, camera) {\n    var boundUniforms = this.boundUniforms;\n\n    for (var name in boundUniforms) {\n      var boundUniform = boundUniforms[name];\n\n      switch (boundUniform.semantic) {\n        case \"MODELVIEW\":\n          var m4 = boundUniform.uniform.value;\n          m4.multiplyMatrices(camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld);\n          break;\n\n        case \"MODELVIEWINVERSETRANSPOSE\":\n          var m3 = boundUniform.uniform.value;\n\n          this._m4.multiplyMatrices(camera.matrixWorldInverse, boundUniform.sourceNode.matrixWorld);\n\n          m3.getNormalMatrix(this._m4);\n          break;\n\n        case \"PROJECTION\":\n          var m4 = boundUniform.uniform.value;\n          m4.copy(camera.projectionMatrix);\n          break;\n\n        case \"JOINTMATRIX\":\n          var m4v = boundUniform.uniform.value;\n\n          for (var mi = 0; mi < m4v.length; mi++) {\n            // So it goes like this:\n            // SkinnedMesh world matrix is already baked into MODELVIEW;\n            // transform joints to local space,\n            // then transform using joint's inverse\n            m4v[mi].getInverse(boundUniform.sourceNode.matrixWorld).multiply(boundUniform.targetNode.skeleton.bones[mi].matrixWorld).multiply(boundUniform.targetNode.skeleton.boneInverses[mi]).multiply(boundUniform.targetNode.bindMatrix);\n          }\n\n          break;\n\n        default:\n          console.warn(\"Unhandled shader semantic: \" + boundUniform.semantic);\n          break;\n      }\n    }\n  };\n  /* ANIMATION */\n\n\n  LegacyGLTFLoader.Animations = {\n    update: function () {\n      console.warn('THREE.LegacyGLTFLoader.Animation has been deprecated. Use THREE.AnimationMixer instead.');\n    }\n  };\n  /*********************************/\n\n  /********** EXTENSIONS ***********/\n\n  /*********************************/\n\n  var EXTENSIONS = {\n    KHR_BINARY_GLTF: 'KHR_binary_glTF',\n    KHR_MATERIALS_COMMON: 'KHR_materials_common'\n  };\n  /* MATERIALS COMMON EXTENSION */\n\n  function GLTFMaterialsCommonExtension(json) {\n    this.name = EXTENSIONS.KHR_MATERIALS_COMMON;\n    this.lights = {};\n    var extension = json.extensions && json.extensions[EXTENSIONS.KHR_MATERIALS_COMMON] || {};\n    var lights = extension.lights || {};\n\n    for (var lightId in lights) {\n      var light = lights[lightId];\n      var lightNode;\n      var lightParams = light[light.type];\n      var color = new THREE.Color().fromArray(lightParams.color);\n\n      switch (light.type) {\n        case \"directional\":\n          lightNode = new THREE.DirectionalLight(color);\n          lightNode.position.set(0, 0, 1);\n          break;\n\n        case \"point\":\n          lightNode = new THREE.PointLight(color);\n          break;\n\n        case \"spot\":\n          lightNode = new THREE.SpotLight(color);\n          lightNode.position.set(0, 0, 1);\n          break;\n\n        case \"ambient\":\n          lightNode = new THREE.AmbientLight(color);\n          break;\n      }\n\n      if (lightNode) {\n        this.lights[lightId] = lightNode;\n      }\n    }\n  }\n  /* BINARY EXTENSION */\n\n\n  var BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';\n  var BINARY_EXTENSION_HEADER_DEFAULTS = {\n    magic: 'glTF',\n    version: 1,\n    contentFormat: 0\n  };\n  var BINARY_EXTENSION_HEADER_LENGTH = 20;\n\n  function GLTFBinaryExtension(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    var header = {\n      magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true),\n      contentLength: headerView.getUint32(12, true),\n      contentFormat: headerView.getUint32(16, true)\n    };\n\n    for (var key in BINARY_EXTENSION_HEADER_DEFAULTS) {\n      var value = BINARY_EXTENSION_HEADER_DEFAULTS[key];\n\n      if (header[key] !== value) {\n        throw new Error('Unsupported glTF-Binary header: Expected \"%s\" to be \"%s\".', key, value);\n      }\n    }\n\n    var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH, header.contentLength);\n    this.header = header;\n    this.content = THREE.LoaderUtils.decodeText(contentArray);\n    this.body = data.slice(BINARY_EXTENSION_HEADER_LENGTH + header.contentLength, header.length);\n  }\n\n  GLTFBinaryExtension.prototype.loadShader = function (shader, bufferViews) {\n    var bufferView = bufferViews[shader.extensions[EXTENSIONS.KHR_BINARY_GLTF].bufferView];\n    var array = new Uint8Array(bufferView);\n    return THREE.LoaderUtils.decodeText(array);\n  };\n  /*********************************/\n\n  /********** INTERNALS ************/\n\n  /*********************************/\n\n  /* CONSTANTS */\n\n\n  var WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    TRIANGLES: 4,\n    LINES: 1,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123,\n    VERTEX_SHADER: 35633,\n    FRAGMENT_SHADER: 35632\n  };\n  var WEBGL_TYPE = {\n    5126: Number,\n    //35674: THREE.Matrix2,\n    35675: THREE.Matrix3,\n    35676: THREE.Matrix4,\n    35664: THREE.Vector2,\n    35665: THREE.Vector3,\n    35666: THREE.Vector4,\n    35678: THREE.Texture\n  };\n  var WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n  };\n  var WEBGL_FILTERS = {\n    9728: THREE.NearestFilter,\n    9729: THREE.LinearFilter,\n    9984: THREE.NearestMipmapNearestFilter,\n    9985: THREE.LinearMipmapNearestFilter,\n    9986: THREE.NearestMipmapLinearFilter,\n    9987: THREE.LinearMipmapLinearFilter\n  };\n  var WEBGL_WRAPPINGS = {\n    33071: THREE.ClampToEdgeWrapping,\n    33648: THREE.MirroredRepeatWrapping,\n    10497: THREE.RepeatWrapping\n  };\n  var WEBGL_TEXTURE_FORMATS = {\n    6406: THREE.AlphaFormat,\n    6407: THREE.RGBFormat,\n    6408: THREE.RGBAFormat,\n    6409: THREE.LuminanceFormat,\n    6410: THREE.LuminanceAlphaFormat\n  };\n  var WEBGL_TEXTURE_DATATYPES = {\n    5121: THREE.UnsignedByteType,\n    32819: THREE.UnsignedShort4444Type,\n    32820: THREE.UnsignedShort5551Type,\n    33635: THREE.UnsignedShort565Type\n  };\n  var WEBGL_SIDES = {\n    1028: THREE.BackSide,\n    // Culling front\n    1029: THREE.FrontSide // Culling back\n    //1032: THREE.NoSide   // Culling front and back, what to do?\n\n  };\n  var WEBGL_DEPTH_FUNCS = {\n    512: THREE.NeverDepth,\n    513: THREE.LessDepth,\n    514: THREE.EqualDepth,\n    515: THREE.LessEqualDepth,\n    516: THREE.GreaterEqualDepth,\n    517: THREE.NotEqualDepth,\n    518: THREE.GreaterEqualDepth,\n    519: THREE.AlwaysDepth\n  };\n  var WEBGL_BLEND_EQUATIONS = {\n    32774: THREE.AddEquation,\n    32778: THREE.SubtractEquation,\n    32779: THREE.ReverseSubtractEquation\n  };\n  var WEBGL_BLEND_FUNCS = {\n    0: THREE.ZeroFactor,\n    1: THREE.OneFactor,\n    768: THREE.SrcColorFactor,\n    769: THREE.OneMinusSrcColorFactor,\n    770: THREE.SrcAlphaFactor,\n    771: THREE.OneMinusSrcAlphaFactor,\n    772: THREE.DstAlphaFactor,\n    773: THREE.OneMinusDstAlphaFactor,\n    774: THREE.DstColorFactor,\n    775: THREE.OneMinusDstColorFactor,\n    776: THREE.SrcAlphaSaturateFactor // The followings are not supported by Three.js yet\n    //32769: CONSTANT_COLOR,\n    //32770: ONE_MINUS_CONSTANT_COLOR,\n    //32771: CONSTANT_ALPHA,\n    //32772: ONE_MINUS_CONSTANT_COLOR\n\n  };\n  var WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n  };\n  var PATH_PROPERTIES = {\n    scale: 'scale',\n    translation: 'position',\n    rotation: 'quaternion'\n  };\n  var INTERPOLATION = {\n    LINEAR: THREE.InterpolateLinear,\n    STEP: THREE.InterpolateDiscrete\n  };\n  var STATES_ENABLES = {\n    2884: 'CULL_FACE',\n    2929: 'DEPTH_TEST',\n    3042: 'BLEND',\n    3089: 'SCISSOR_TEST',\n    32823: 'POLYGON_OFFSET_FILL',\n    32926: 'SAMPLE_ALPHA_TO_COVERAGE'\n  };\n  /* UTILITY FUNCTIONS */\n\n  function _each(object, callback, thisObj) {\n    if (!object) {\n      return Promise.resolve();\n    }\n\n    var results;\n    var fns = [];\n\n    if (Object.prototype.toString.call(object) === '[object Array]') {\n      results = [];\n      var length = object.length;\n\n      for (var idx = 0; idx < length; idx++) {\n        var value = callback.call(thisObj || this, object[idx], idx);\n\n        if (value) {\n          fns.push(value);\n\n          if (value instanceof Promise) {\n            value.then(function (key, value) {\n              results[key] = value;\n            }.bind(this, idx));\n          } else {\n            results[idx] = value;\n          }\n        }\n      }\n    } else {\n      results = {};\n\n      for (var key in object) {\n        if (object.hasOwnProperty(key)) {\n          var value = callback.call(thisObj || this, object[key], key);\n\n          if (value) {\n            fns.push(value);\n\n            if (value instanceof Promise) {\n              value.then(function (key, value) {\n                results[key] = value;\n              }.bind(this, key));\n            } else {\n              results[key] = value;\n            }\n          }\n        }\n      }\n    }\n\n    return Promise.all(fns).then(function () {\n      return results;\n    });\n  }\n\n  function resolveURL(url, path) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') return ''; // Absolute URL http://,https://,//\n\n    if (/^(https?:)?\\/\\//i.test(url)) {\n      return url;\n    } // Data URI\n\n\n    if (/^data:.*,.*$/i.test(url)) {\n      return url;\n    } // Blob URL\n\n\n    if (/^blob:.*$/i.test(url)) {\n      return url;\n    } // Relative URL\n\n\n    return (path || '') + url;\n  } // Three.js seems too dependent on attribute names so globally\n  // replace those in the shader code\n\n\n  function replaceTHREEShaderAttributes(shaderText, technique) {\n    // Expected technique attributes\n    var attributes = {};\n\n    for (var attributeId in technique.attributes) {\n      var pname = technique.attributes[attributeId];\n      var param = technique.parameters[pname];\n      var atype = param.type;\n      var semantic = param.semantic;\n      attributes[attributeId] = {\n        type: atype,\n        semantic: semantic\n      };\n    } // Figure out which attributes to change in technique\n\n\n    var shaderParams = technique.parameters;\n    var shaderAttributes = technique.attributes;\n    var params = {};\n\n    for (var attributeId in attributes) {\n      var pname = shaderAttributes[attributeId];\n      var shaderParam = shaderParams[pname];\n      var semantic = shaderParam.semantic;\n\n      if (semantic) {\n        params[attributeId] = shaderParam;\n      }\n    }\n\n    for (var pname in params) {\n      var param = params[pname];\n      var semantic = param.semantic;\n      var regEx = new RegExp(\"\\\\b\" + pname + \"\\\\b\", \"g\");\n\n      switch (semantic) {\n        case \"POSITION\":\n          shaderText = shaderText.replace(regEx, 'position');\n          break;\n\n        case \"NORMAL\":\n          shaderText = shaderText.replace(regEx, 'normal');\n          break;\n\n        case 'TEXCOORD_0':\n        case 'TEXCOORD0':\n        case 'TEXCOORD':\n          shaderText = shaderText.replace(regEx, 'uv');\n          break;\n\n        case 'TEXCOORD_1':\n          shaderText = shaderText.replace(regEx, 'uv2');\n          break;\n\n        case 'COLOR_0':\n        case 'COLOR0':\n        case 'COLOR':\n          shaderText = shaderText.replace(regEx, 'color');\n          break;\n\n        case \"WEIGHT\":\n          shaderText = shaderText.replace(regEx, 'skinWeight');\n          break;\n\n        case \"JOINT\":\n          shaderText = shaderText.replace(regEx, 'skinIndex');\n          break;\n      }\n    }\n\n    return shaderText;\n  }\n\n  function createDefaultMaterial() {\n    return new THREE.MeshPhongMaterial({\n      color: 0x00000,\n      emissive: 0x888888,\n      specular: 0x000000,\n      shininess: 0,\n      transparent: false,\n      depthTest: true,\n      side: THREE.FrontSide\n    });\n  } // Deferred constructor for RawShaderMaterial types\n\n\n  function DeferredShaderMaterial(params) {\n    this.isDeferredShaderMaterial = true;\n    this.params = params;\n  }\n\n  DeferredShaderMaterial.prototype.create = function () {\n    var uniforms = THREE.UniformsUtils.clone(this.params.uniforms);\n\n    for (var uniformId in this.params.uniforms) {\n      var originalUniform = this.params.uniforms[uniformId];\n\n      if (originalUniform.value instanceof THREE.Texture) {\n        uniforms[uniformId].value = originalUniform.value;\n        uniforms[uniformId].value.needsUpdate = true;\n      }\n\n      uniforms[uniformId].semantic = originalUniform.semantic;\n      uniforms[uniformId].node = originalUniform.node;\n    }\n\n    this.params.uniforms = uniforms;\n    return new THREE.RawShaderMaterial(this.params);\n  };\n  /* GLTF PARSER */\n\n\n  function GLTFParser(json, extensions, options) {\n    this.json = json || {};\n    this.extensions = extensions || {};\n    this.options = options || {}; // loader object cache\n\n    this.cache = new GLTFRegistry();\n  }\n\n  GLTFParser.prototype._withDependencies = function (dependencies) {\n    var _dependencies = {};\n\n    for (var i = 0; i < dependencies.length; i++) {\n      var dependency = dependencies[i];\n      var fnName = \"load\" + dependency.charAt(0).toUpperCase() + dependency.slice(1);\n      var cached = this.cache.get(dependency);\n\n      if (cached !== undefined) {\n        _dependencies[dependency] = cached;\n      } else if (this[fnName]) {\n        var fn = this[fnName]();\n        this.cache.add(dependency, fn);\n        _dependencies[dependency] = fn;\n      }\n    }\n\n    return _each(_dependencies, function (dependency) {\n      return dependency;\n    });\n  };\n\n  GLTFParser.prototype.parse = function (callback) {\n    var json = this.json; // Clear the loader cache\n\n    this.cache.removeAll(); // Fire the callback on complete\n\n    this._withDependencies([\"scenes\", \"cameras\", \"animations\"]).then(function (dependencies) {\n      var scenes = [];\n\n      for (var name in dependencies.scenes) {\n        scenes.push(dependencies.scenes[name]);\n      }\n\n      var scene = json.scene !== undefined ? dependencies.scenes[json.scene] : scenes[0];\n      var cameras = [];\n\n      for (var name in dependencies.cameras) {\n        var camera = dependencies.cameras[name];\n        cameras.push(camera);\n      }\n\n      var animations = [];\n\n      for (var name in dependencies.animations) {\n        animations.push(dependencies.animations[name]);\n      }\n\n      callback(scene, scenes, cameras, animations);\n    });\n  };\n\n  GLTFParser.prototype.loadShaders = function () {\n    var json = this.json;\n    var extensions = this.extensions;\n    var options = this.options;\n    return this._withDependencies([\"bufferViews\"]).then(function (dependencies) {\n      return _each(json.shaders, function (shader) {\n        if (shader.extensions && shader.extensions[EXTENSIONS.KHR_BINARY_GLTF]) {\n          return extensions[EXTENSIONS.KHR_BINARY_GLTF].loadShader(shader, dependencies.bufferViews);\n        }\n\n        return new Promise(function (resolve) {\n          var loader = new THREE.FileLoader(options.manager);\n          loader.setResponseType('text');\n          loader.load(resolveURL(shader.uri, options.path), function (shaderText) {\n            resolve(shaderText);\n          });\n        });\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadBuffers = function () {\n    var json = this.json;\n    var extensions = this.extensions;\n    var options = this.options;\n    return _each(json.buffers, function (buffer, name) {\n      if (name === BINARY_EXTENSION_BUFFER_NAME) {\n        return extensions[EXTENSIONS.KHR_BINARY_GLTF].body;\n      }\n\n      if (buffer.type === 'arraybuffer' || buffer.type === undefined) {\n        return new Promise(function (resolve) {\n          var loader = new THREE.FileLoader(options.manager);\n          loader.setResponseType('arraybuffer');\n          loader.load(resolveURL(buffer.uri, options.path), function (buffer) {\n            resolve(buffer);\n          });\n        });\n      } else {\n        console.warn('THREE.LegacyGLTFLoader: ' + buffer.type + ' buffer type is not supported');\n      }\n    });\n  };\n\n  GLTFParser.prototype.loadBufferViews = function () {\n    var json = this.json;\n    return this._withDependencies([\"buffers\"]).then(function (dependencies) {\n      return _each(json.bufferViews, function (bufferView) {\n        var arraybuffer = dependencies.buffers[bufferView.buffer];\n        var byteLength = bufferView.byteLength !== undefined ? bufferView.byteLength : 0;\n        return arraybuffer.slice(bufferView.byteOffset, bufferView.byteOffset + byteLength);\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadAccessors = function () {\n    var json = this.json;\n    return this._withDependencies([\"bufferViews\"]).then(function (dependencies) {\n      return _each(json.accessors, function (accessor) {\n        var arraybuffer = dependencies.bufferViews[accessor.bufferView];\n        var itemSize = WEBGL_TYPE_SIZES[accessor.type];\n        var TypedArray = WEBGL_COMPONENT_TYPES[accessor.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n        var elementBytes = TypedArray.BYTES_PER_ELEMENT;\n        var itemBytes = elementBytes * itemSize; // The buffer is not interleaved if the stride is the item size in bytes.\n\n        if (accessor.byteStride && accessor.byteStride !== itemBytes) {\n          // Use the full buffer if it's interleaved.\n          var array = new TypedArray(arraybuffer); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n          var ib = new THREE.InterleavedBuffer(array, accessor.byteStride / elementBytes);\n          return new THREE.InterleavedBufferAttribute(ib, itemSize, accessor.byteOffset / elementBytes);\n        } else {\n          array = new TypedArray(arraybuffer, accessor.byteOffset, accessor.count * itemSize);\n          return new THREE.BufferAttribute(array, itemSize);\n        }\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadTextures = function () {\n    var json = this.json;\n    var options = this.options;\n    return this._withDependencies([\"bufferViews\"]).then(function (dependencies) {\n      return _each(json.textures, function (texture) {\n        if (texture.source) {\n          return new Promise(function (resolve) {\n            var source = json.images[texture.source];\n            var sourceUri = source.uri;\n            var isObjectURL = false;\n\n            if (source.extensions && source.extensions[EXTENSIONS.KHR_BINARY_GLTF]) {\n              var metadata = source.extensions[EXTENSIONS.KHR_BINARY_GLTF];\n              var bufferView = dependencies.bufferViews[metadata.bufferView];\n              var blob = new Blob([bufferView], {\n                type: metadata.mimeType\n              });\n              sourceUri = URL.createObjectURL(blob);\n              isObjectURL = true;\n            }\n\n            var textureLoader = options.manager.getHandler(sourceUri);\n\n            if (textureLoader === null) {\n              textureLoader = new THREE.TextureLoader(options.manager);\n            }\n\n            textureLoader.setCrossOrigin(options.crossOrigin);\n            textureLoader.load(resolveURL(sourceUri, options.path), function (_texture) {\n              if (isObjectURL) URL.revokeObjectURL(sourceUri);\n              _texture.flipY = false;\n              if (texture.name !== undefined) _texture.name = texture.name;\n              _texture.format = texture.format !== undefined ? WEBGL_TEXTURE_FORMATS[texture.format] : THREE.RGBAFormat;\n\n              if (texture.internalFormat !== undefined && _texture.format !== WEBGL_TEXTURE_FORMATS[texture.internalFormat]) {\n                console.warn('THREE.LegacyGLTFLoader: Three.js doesn\\'t support texture internalFormat which is different from texture format. ' + 'internalFormat will be forced to be the same value as format.');\n              }\n\n              _texture.type = texture.type !== undefined ? WEBGL_TEXTURE_DATATYPES[texture.type] : THREE.UnsignedByteType;\n\n              if (texture.sampler) {\n                var sampler = json.samplers[texture.sampler];\n                _texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\n                _texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.NearestMipmapLinearFilter;\n                _texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\n                _texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\n              }\n\n              resolve(_texture);\n            }, undefined, function () {\n              if (isObjectURL) URL.revokeObjectURL(sourceUri);\n              resolve();\n            });\n          });\n        }\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadMaterials = function () {\n    var json = this.json;\n    return this._withDependencies([\"shaders\", \"textures\"]).then(function (dependencies) {\n      return _each(json.materials, function (material) {\n        var materialType;\n        var materialValues = {};\n        var materialParams = {};\n        var khr_material;\n\n        if (material.extensions && material.extensions[EXTENSIONS.KHR_MATERIALS_COMMON]) {\n          khr_material = material.extensions[EXTENSIONS.KHR_MATERIALS_COMMON];\n        }\n\n        if (khr_material) {\n          // don't copy over unused values to avoid material warning spam\n          var keys = ['ambient', 'emission', 'transparent', 'transparency', 'doubleSided'];\n\n          switch (khr_material.technique) {\n            case 'BLINN':\n            case 'PHONG':\n              materialType = THREE.MeshPhongMaterial;\n              keys.push('diffuse', 'specular', 'shininess');\n              break;\n\n            case 'LAMBERT':\n              materialType = THREE.MeshLambertMaterial;\n              keys.push('diffuse');\n              break;\n\n            case 'CONSTANT':\n            default:\n              materialType = THREE.MeshBasicMaterial;\n              break;\n          }\n\n          keys.forEach(function (v) {\n            if (khr_material.values[v] !== undefined) materialValues[v] = khr_material.values[v];\n          });\n\n          if (khr_material.doubleSided || materialValues.doubleSided) {\n            materialParams.side = THREE.DoubleSide;\n          }\n\n          if (khr_material.transparent || materialValues.transparent) {\n            materialParams.transparent = true;\n            materialParams.opacity = materialValues.transparency !== undefined ? materialValues.transparency : 1;\n          }\n        } else if (material.technique === undefined) {\n          materialType = THREE.MeshPhongMaterial;\n          Object.assign(materialValues, material.values);\n        } else {\n          materialType = DeferredShaderMaterial;\n          var technique = json.techniques[material.technique];\n          materialParams.uniforms = {};\n          var program = json.programs[technique.program];\n\n          if (program) {\n            materialParams.fragmentShader = dependencies.shaders[program.fragmentShader];\n\n            if (!materialParams.fragmentShader) {\n              console.warn(\"ERROR: Missing fragment shader definition:\", program.fragmentShader);\n              materialType = THREE.MeshPhongMaterial;\n            }\n\n            var vertexShader = dependencies.shaders[program.vertexShader];\n\n            if (!vertexShader) {\n              console.warn(\"ERROR: Missing vertex shader definition:\", program.vertexShader);\n              materialType = THREE.MeshPhongMaterial;\n            } // IMPORTANT: FIX VERTEX SHADER ATTRIBUTE DEFINITIONS\n\n\n            materialParams.vertexShader = replaceTHREEShaderAttributes(vertexShader, technique);\n            var uniforms = technique.uniforms;\n\n            for (var uniformId in uniforms) {\n              var pname = uniforms[uniformId];\n              var shaderParam = technique.parameters[pname];\n              var ptype = shaderParam.type;\n\n              if (WEBGL_TYPE[ptype]) {\n                var pcount = shaderParam.count;\n                var value;\n                if (material.values !== undefined) value = material.values[pname];\n                var uvalue = new WEBGL_TYPE[ptype]();\n                var usemantic = shaderParam.semantic;\n                var unode = shaderParam.node;\n\n                switch (ptype) {\n                  case WEBGL_CONSTANTS.FLOAT:\n                    uvalue = shaderParam.value;\n\n                    if (pname == \"transparency\") {\n                      materialParams.transparent = true;\n                    }\n\n                    if (value !== undefined) {\n                      uvalue = value;\n                    }\n\n                    break;\n\n                  case WEBGL_CONSTANTS.FLOAT_VEC2:\n                  case WEBGL_CONSTANTS.FLOAT_VEC3:\n                  case WEBGL_CONSTANTS.FLOAT_VEC4:\n                  case WEBGL_CONSTANTS.FLOAT_MAT3:\n                    if (shaderParam && shaderParam.value) {\n                      uvalue.fromArray(shaderParam.value);\n                    }\n\n                    if (value) {\n                      uvalue.fromArray(value);\n                    }\n\n                    break;\n\n                  case WEBGL_CONSTANTS.FLOAT_MAT2:\n                    // what to do?\n                    console.warn(\"FLOAT_MAT2 is not a supported uniform type\");\n                    break;\n\n                  case WEBGL_CONSTANTS.FLOAT_MAT4:\n                    if (pcount) {\n                      uvalue = new Array(pcount);\n\n                      for (var mi = 0; mi < pcount; mi++) {\n                        uvalue[mi] = new WEBGL_TYPE[ptype]();\n                      }\n\n                      if (shaderParam && shaderParam.value) {\n                        var m4v = shaderParam.value;\n                        uvalue.fromArray(m4v);\n                      }\n\n                      if (value) {\n                        uvalue.fromArray(value);\n                      }\n                    } else {\n                      if (shaderParam && shaderParam.value) {\n                        var m4 = shaderParam.value;\n                        uvalue.fromArray(m4);\n                      }\n\n                      if (value) {\n                        uvalue.fromArray(value);\n                      }\n                    }\n\n                    break;\n\n                  case WEBGL_CONSTANTS.SAMPLER_2D:\n                    if (value !== undefined) {\n                      uvalue = dependencies.textures[value];\n                    } else if (shaderParam.value !== undefined) {\n                      uvalue = dependencies.textures[shaderParam.value];\n                    } else {\n                      uvalue = null;\n                    }\n\n                    break;\n                }\n\n                materialParams.uniforms[uniformId] = {\n                  value: uvalue,\n                  semantic: usemantic,\n                  node: unode\n                };\n              } else {\n                throw new Error(\"Unknown shader uniform param type: \" + ptype);\n              }\n            }\n\n            var states = technique.states || {};\n            var enables = states.enable || [];\n            var functions = states.functions || {};\n            var enableCullFace = false;\n            var enableDepthTest = false;\n            var enableBlend = false;\n\n            for (var i = 0, il = enables.length; i < il; i++) {\n              var enable = enables[i];\n\n              switch (STATES_ENABLES[enable]) {\n                case 'CULL_FACE':\n                  enableCullFace = true;\n                  break;\n\n                case 'DEPTH_TEST':\n                  enableDepthTest = true;\n                  break;\n\n                case 'BLEND':\n                  enableBlend = true;\n                  break;\n                // TODO: implement\n\n                case 'SCISSOR_TEST':\n                case 'POLYGON_OFFSET_FILL':\n                case 'SAMPLE_ALPHA_TO_COVERAGE':\n                  break;\n\n                default:\n                  throw new Error(\"Unknown technique.states.enable: \" + enable);\n              }\n            }\n\n            if (enableCullFace) {\n              materialParams.side = functions.cullFace !== undefined ? WEBGL_SIDES[functions.cullFace] : THREE.FrontSide;\n            } else {\n              materialParams.side = THREE.DoubleSide;\n            }\n\n            materialParams.depthTest = enableDepthTest;\n            materialParams.depthFunc = functions.depthFunc !== undefined ? WEBGL_DEPTH_FUNCS[functions.depthFunc] : THREE.LessDepth;\n            materialParams.depthWrite = functions.depthMask !== undefined ? functions.depthMask[0] : true;\n            materialParams.blending = enableBlend ? THREE.CustomBlending : THREE.NoBlending;\n            materialParams.transparent = enableBlend;\n            var blendEquationSeparate = functions.blendEquationSeparate;\n\n            if (blendEquationSeparate !== undefined) {\n              materialParams.blendEquation = WEBGL_BLEND_EQUATIONS[blendEquationSeparate[0]];\n              materialParams.blendEquationAlpha = WEBGL_BLEND_EQUATIONS[blendEquationSeparate[1]];\n            } else {\n              materialParams.blendEquation = THREE.AddEquation;\n              materialParams.blendEquationAlpha = THREE.AddEquation;\n            }\n\n            var blendFuncSeparate = functions.blendFuncSeparate;\n\n            if (blendFuncSeparate !== undefined) {\n              materialParams.blendSrc = WEBGL_BLEND_FUNCS[blendFuncSeparate[0]];\n              materialParams.blendDst = WEBGL_BLEND_FUNCS[blendFuncSeparate[1]];\n              materialParams.blendSrcAlpha = WEBGL_BLEND_FUNCS[blendFuncSeparate[2]];\n              materialParams.blendDstAlpha = WEBGL_BLEND_FUNCS[blendFuncSeparate[3]];\n            } else {\n              materialParams.blendSrc = THREE.OneFactor;\n              materialParams.blendDst = THREE.ZeroFactor;\n              materialParams.blendSrcAlpha = THREE.OneFactor;\n              materialParams.blendDstAlpha = THREE.ZeroFactor;\n            }\n          }\n        }\n\n        if (Array.isArray(materialValues.diffuse)) {\n          materialParams.color = new THREE.Color().fromArray(materialValues.diffuse);\n        } else if (typeof materialValues.diffuse === 'string') {\n          materialParams.map = dependencies.textures[materialValues.diffuse];\n        }\n\n        delete materialParams.diffuse;\n\n        if (typeof materialValues.reflective === 'string') {\n          materialParams.envMap = dependencies.textures[materialValues.reflective];\n        }\n\n        if (typeof materialValues.bump === 'string') {\n          materialParams.bumpMap = dependencies.textures[materialValues.bump];\n        }\n\n        if (Array.isArray(materialValues.emission)) {\n          if (materialType === THREE.MeshBasicMaterial) {\n            materialParams.color = new THREE.Color().fromArray(materialValues.emission);\n          } else {\n            materialParams.emissive = new THREE.Color().fromArray(materialValues.emission);\n          }\n        } else if (typeof materialValues.emission === 'string') {\n          if (materialType === THREE.MeshBasicMaterial) {\n            materialParams.map = dependencies.textures[materialValues.emission];\n          } else {\n            materialParams.emissiveMap = dependencies.textures[materialValues.emission];\n          }\n        }\n\n        if (Array.isArray(materialValues.specular)) {\n          materialParams.specular = new THREE.Color().fromArray(materialValues.specular);\n        } else if (typeof materialValues.specular === 'string') {\n          materialParams.specularMap = dependencies.textures[materialValues.specular];\n        }\n\n        if (materialValues.shininess !== undefined) {\n          materialParams.shininess = materialValues.shininess;\n        }\n\n        var _material = new materialType(materialParams);\n\n        if (material.name !== undefined) _material.name = material.name;\n        return _material;\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadMeshes = function () {\n    var json = this.json;\n    return this._withDependencies([\"accessors\", \"materials\"]).then(function (dependencies) {\n      return _each(json.meshes, function (mesh) {\n        var group = new THREE.Group();\n        if (mesh.name !== undefined) group.name = mesh.name;\n        if (mesh.extras) group.userData = mesh.extras;\n        var primitives = mesh.primitives || [];\n\n        for (var name in primitives) {\n          var primitive = primitives[name];\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === undefined) {\n            var geometry = new THREE.BufferGeometry();\n            var attributes = primitive.attributes;\n\n            for (var attributeId in attributes) {\n              var attributeEntry = attributes[attributeId];\n              if (!attributeEntry) return;\n              var bufferAttribute = dependencies.accessors[attributeEntry];\n\n              switch (attributeId) {\n                case 'POSITION':\n                  geometry.setAttribute('position', bufferAttribute);\n                  break;\n\n                case 'NORMAL':\n                  geometry.setAttribute('normal', bufferAttribute);\n                  break;\n\n                case 'TEXCOORD_0':\n                case 'TEXCOORD0':\n                case 'TEXCOORD':\n                  geometry.setAttribute('uv', bufferAttribute);\n                  break;\n\n                case 'TEXCOORD_1':\n                  geometry.setAttribute('uv2', bufferAttribute);\n                  break;\n\n                case 'COLOR_0':\n                case 'COLOR0':\n                case 'COLOR':\n                  geometry.setAttribute('color', bufferAttribute);\n                  break;\n\n                case 'WEIGHT':\n                  geometry.setAttribute('skinWeight', bufferAttribute);\n                  break;\n\n                case 'JOINT':\n                  geometry.setAttribute('skinIndex', bufferAttribute);\n                  break;\n\n                default:\n                  if (!primitive.material) break;\n                  var material = json.materials[primitive.material];\n                  if (!material.technique) break;\n                  var parameters = json.techniques[material.technique].parameters || {};\n\n                  for (var attributeName in parameters) {\n                    if (parameters[attributeName]['semantic'] === attributeId) {\n                      geometry.setAttribute(attributeName, bufferAttribute);\n                    }\n                  }\n\n              }\n            }\n\n            if (primitive.indices) {\n              geometry.setIndex(dependencies.accessors[primitive.indices]);\n            }\n\n            var material = dependencies.materials !== undefined ? dependencies.materials[primitive.material] : createDefaultMaterial();\n            var meshNode = new THREE.Mesh(geometry, material);\n            meshNode.castShadow = true;\n            meshNode.name = name === \"0\" ? group.name : group.name + name;\n            if (primitive.extras) meshNode.userData = primitive.extras;\n            group.add(meshNode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n            var geometry = new THREE.BufferGeometry();\n            var attributes = primitive.attributes;\n\n            for (var attributeId in attributes) {\n              var attributeEntry = attributes[attributeId];\n              if (!attributeEntry) return;\n              var bufferAttribute = dependencies.accessors[attributeEntry];\n\n              switch (attributeId) {\n                case 'POSITION':\n                  geometry.setAttribute('position', bufferAttribute);\n                  break;\n\n                case 'COLOR_0':\n                case 'COLOR0':\n                case 'COLOR':\n                  geometry.setAttribute('color', bufferAttribute);\n                  break;\n              }\n            }\n\n            var material = dependencies.materials[primitive.material];\n            var meshNode;\n\n            if (primitive.indices) {\n              geometry.setIndex(dependencies.accessors[primitive.indices]);\n              meshNode = new THREE.LineSegments(geometry, material);\n            } else {\n              meshNode = new THREE.Line(geometry, material);\n            }\n\n            meshNode.name = name === \"0\" ? group.name : group.name + name;\n            if (primitive.extras) meshNode.userData = primitive.extras;\n            group.add(meshNode);\n          } else {\n            console.warn(\"Only triangular and line primitives are supported\");\n          }\n        }\n\n        return group;\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadCameras = function () {\n    var json = this.json;\n    return _each(json.cameras, function (camera) {\n      if (camera.type == \"perspective\" && camera.perspective) {\n        var yfov = camera.perspective.yfov;\n        var aspectRatio = camera.perspective.aspectRatio !== undefined ? camera.perspective.aspectRatio : 1; // According to COLLADA spec...\n        // aspectRatio = xfov / yfov\n\n        var xfov = yfov * aspectRatio;\n\n        var _camera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(xfov), aspectRatio, camera.perspective.znear || 1, camera.perspective.zfar || 2e6);\n\n        if (camera.name !== undefined) _camera.name = camera.name;\n        if (camera.extras) _camera.userData = camera.extras;\n        return _camera;\n      } else if (camera.type == \"orthographic\" && camera.orthographic) {\n        var _camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, camera.orthographic.znear, camera.orthographic.zfar);\n\n        if (camera.name !== undefined) _camera.name = camera.name;\n        if (camera.extras) _camera.userData = camera.extras;\n        return _camera;\n      }\n    });\n  };\n\n  GLTFParser.prototype.loadSkins = function () {\n    var json = this.json;\n    return this._withDependencies([\"accessors\"]).then(function (dependencies) {\n      return _each(json.skins, function (skin) {\n        var bindShapeMatrix = new THREE.Matrix4();\n        if (skin.bindShapeMatrix !== undefined) bindShapeMatrix.fromArray(skin.bindShapeMatrix);\n        var _skin = {\n          bindShapeMatrix: bindShapeMatrix,\n          jointNames: skin.jointNames,\n          inverseBindMatrices: dependencies.accessors[skin.inverseBindMatrices]\n        };\n        return _skin;\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadAnimations = function () {\n    var json = this.json;\n    return this._withDependencies([\"accessors\", \"nodes\"]).then(function (dependencies) {\n      return _each(json.animations, function (animation, animationId) {\n        var tracks = [];\n\n        for (var channelId in animation.channels) {\n          var channel = animation.channels[channelId];\n          var sampler = animation.samplers[channel.sampler];\n\n          if (sampler) {\n            var target = channel.target;\n            var name = target.id;\n            var input = animation.parameters !== undefined ? animation.parameters[sampler.input] : sampler.input;\n            var output = animation.parameters !== undefined ? animation.parameters[sampler.output] : sampler.output;\n            var inputAccessor = dependencies.accessors[input];\n            var outputAccessor = dependencies.accessors[output];\n            var node = dependencies.nodes[name];\n\n            if (node) {\n              node.updateMatrix();\n              node.matrixAutoUpdate = true;\n              var TypedKeyframeTrack = PATH_PROPERTIES[target.path] === PATH_PROPERTIES.rotation ? THREE.QuaternionKeyframeTrack : THREE.VectorKeyframeTrack;\n              var targetName = node.name ? node.name : node.uuid;\n              var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear; // KeyframeTrack.optimize() will modify given 'times' and 'values'\n              // buffers before creating a truncated copy to keep. Because buffers may\n              // be reused by other tracks, make copies here.\n\n              tracks.push(new TypedKeyframeTrack(targetName + '.' + PATH_PROPERTIES[target.path], THREE.AnimationUtils.arraySlice(inputAccessor.array, 0), THREE.AnimationUtils.arraySlice(outputAccessor.array, 0), interpolation));\n            }\n          }\n        }\n\n        var name = animation.name !== undefined ? animation.name : \"animation_\" + animationId;\n        return new THREE.AnimationClip(name, undefined, tracks);\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadNodes = function () {\n    var json = this.json;\n    var extensions = this.extensions;\n    var scope = this;\n    return _each(json.nodes, function (node) {\n      var matrix = new THREE.Matrix4();\n\n      var _node;\n\n      if (node.jointName) {\n        _node = new THREE.Bone();\n        _node.name = node.name !== undefined ? node.name : node.jointName;\n        _node.jointName = node.jointName;\n      } else {\n        _node = new THREE.Object3D();\n        if (node.name !== undefined) _node.name = node.name;\n      }\n\n      if (node.extras) _node.userData = node.extras;\n\n      if (node.matrix !== undefined) {\n        matrix.fromArray(node.matrix);\n\n        _node.applyMatrix(matrix);\n      } else {\n        if (node.translation !== undefined) {\n          _node.position.fromArray(node.translation);\n        }\n\n        if (node.rotation !== undefined) {\n          _node.quaternion.fromArray(node.rotation);\n        }\n\n        if (node.scale !== undefined) {\n          _node.scale.fromArray(node.scale);\n        }\n      }\n\n      return _node;\n    }).then(function (__nodes) {\n      return scope._withDependencies([\"meshes\", \"skins\", \"cameras\"]).then(function (dependencies) {\n        return _each(__nodes, function (_node, nodeId) {\n          var node = json.nodes[nodeId];\n\n          if (node.meshes !== undefined) {\n            for (var meshId in node.meshes) {\n              var mesh = node.meshes[meshId];\n              var group = dependencies.meshes[mesh];\n\n              if (group === undefined) {\n                console.warn('LegacyGLTFLoader: Couldn\\'t find node \"' + mesh + '\".');\n                continue;\n              }\n\n              for (var childrenId in group.children) {\n                var child = group.children[childrenId]; // clone Mesh to add to _node\n\n                var originalMaterial = child.material;\n                var originalGeometry = child.geometry;\n                var originalUserData = child.userData;\n                var originalName = child.name;\n                var material;\n\n                if (originalMaterial.isDeferredShaderMaterial) {\n                  originalMaterial = material = originalMaterial.create();\n                } else {\n                  material = originalMaterial;\n                }\n\n                switch (child.type) {\n                  case 'LineSegments':\n                    child = new THREE.LineSegments(originalGeometry, material);\n                    break;\n\n                  case 'LineLoop':\n                    child = new THREE.LineLoop(originalGeometry, material);\n                    break;\n\n                  case 'Line':\n                    child = new THREE.Line(originalGeometry, material);\n                    break;\n\n                  default:\n                    child = new THREE.Mesh(originalGeometry, material);\n                }\n\n                child.castShadow = true;\n                child.userData = originalUserData;\n                child.name = originalName;\n                var skinEntry;\n\n                if (node.skin) {\n                  skinEntry = dependencies.skins[node.skin];\n                } // Replace Mesh with SkinnedMesh in library\n\n\n                if (skinEntry) {\n                  var getJointNode = function (jointId) {\n                    var keys = Object.keys(__nodes);\n\n                    for (var i = 0, il = keys.length; i < il; i++) {\n                      var n = __nodes[keys[i]];\n                      if (n.jointName === jointId) return n;\n                    }\n\n                    return null;\n                  };\n\n                  var geometry = originalGeometry;\n                  var material = originalMaterial;\n                  material.skinning = true;\n                  child = new THREE.SkinnedMesh(geometry, material);\n                  child.castShadow = true;\n                  child.userData = originalUserData;\n                  child.name = originalName;\n                  var bones = [];\n                  var boneInverses = [];\n\n                  for (var i = 0, l = skinEntry.jointNames.length; i < l; i++) {\n                    var jointId = skinEntry.jointNames[i];\n                    var jointNode = getJointNode(jointId);\n\n                    if (jointNode) {\n                      bones.push(jointNode);\n                      var m = skinEntry.inverseBindMatrices.array;\n                      var mat = new THREE.Matrix4().fromArray(m, i * 16);\n                      boneInverses.push(mat);\n                    } else {\n                      console.warn(\"WARNING: joint: '\" + jointId + \"' could not be found\");\n                    }\n                  }\n\n                  child.bind(new THREE.Skeleton(bones, boneInverses), skinEntry.bindShapeMatrix);\n\n                  var buildBoneGraph = function (parentJson, parentObject, property) {\n                    var children = parentJson[property];\n                    if (children === undefined) return;\n\n                    for (var i = 0, il = children.length; i < il; i++) {\n                      var nodeId = children[i];\n                      var bone = __nodes[nodeId];\n                      var boneJson = json.nodes[nodeId];\n\n                      if (bone !== undefined && bone.isBone === true && boneJson !== undefined) {\n                        parentObject.add(bone);\n                        buildBoneGraph(boneJson, bone, 'children');\n                      }\n                    }\n                  };\n\n                  buildBoneGraph(node, child, 'skeletons');\n                }\n\n                _node.add(child);\n              }\n            }\n          }\n\n          if (node.camera !== undefined) {\n            var camera = dependencies.cameras[node.camera];\n\n            _node.add(camera);\n          }\n\n          if (node.extensions && node.extensions[EXTENSIONS.KHR_MATERIALS_COMMON] && node.extensions[EXTENSIONS.KHR_MATERIALS_COMMON].light) {\n            var extensionLights = extensions[EXTENSIONS.KHR_MATERIALS_COMMON].lights;\n            var light = extensionLights[node.extensions[EXTENSIONS.KHR_MATERIALS_COMMON].light];\n\n            _node.add(light);\n          }\n\n          return _node;\n        });\n      });\n    });\n  };\n\n  GLTFParser.prototype.loadScenes = function () {\n    var json = this.json; // scene node hierachy builder\n\n    function buildNodeHierachy(nodeId, parentObject, allNodes) {\n      var _node = allNodes[nodeId];\n      parentObject.add(_node);\n      var node = json.nodes[nodeId];\n\n      if (node.children) {\n        var children = node.children;\n\n        for (var i = 0, l = children.length; i < l; i++) {\n          var child = children[i];\n          buildNodeHierachy(child, _node, allNodes);\n        }\n      }\n    }\n\n    return this._withDependencies([\"nodes\"]).then(function (dependencies) {\n      return _each(json.scenes, function (scene) {\n        var _scene = new THREE.Scene();\n\n        if (scene.name !== undefined) _scene.name = scene.name;\n        if (scene.extras) _scene.userData = scene.extras;\n        var nodes = scene.nodes || [];\n\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          var nodeId = nodes[i];\n          buildNodeHierachy(nodeId, _scene, dependencies.nodes);\n        }\n\n        _scene.traverse(function (child) {\n          // Register raw material meshes with LegacyGLTFLoader.Shaders\n          if (child.material && child.material.isRawShaderMaterial) {\n            child.gltfShader = new GLTFShader(child, dependencies.nodes);\n\n            child.onBeforeRender = function (renderer, scene, camera) {\n              this.gltfShader.update(scene, camera);\n            };\n          }\n        });\n\n        return _scene;\n      });\n    });\n  };\n\n  return LegacyGLTFLoader;\n}();\n\n//# sourceURL=webpack:///./lib/LegacyGLTFLoader.js?");

/***/ })

/******/ });
});
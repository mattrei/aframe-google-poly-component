!function(e,o){if("object"==typeof exports&&"object"==typeof module)module.exports=o();else if("function"==typeof define&&define.amd)define([],o);else{var t=o();for(var r in t)("object"==typeof exports?exports:e)[r]=t[r]}}(this,function(){return function(e){var o={};function t(r){if(o[r])return o[r].exports;var n=o[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,t),n.l=!0,n.exports}return t.m=e,t.c=o,t.d=function(e,o,r){t.o(e,o)||Object.defineProperty(e,o,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,o){if(1&o&&(e=t(e)),8&o)return e;if(4&o&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&o&&"string"!=typeof e)for(var n in e)t.d(r,n,function(o){return e[o]}.bind(null,n));return r},t.n=function(e){var o=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(o,"a",o),o},t.o=function(e,o){return Object.prototype.hasOwnProperty.call(e,o)},t.p="",t(t.s=0)}([function(e,o){if("undefined"==typeof AFRAME)throw new Error("Component attempted to register before AFRAME was available.");AFRAME.registerComponent("google-poly",{schema:{apiKey:{default:""},src:{},normalize:{type:"boolean",default:!0}},multiple:!1,init:function(){this.model=null},update:function(e){const o=this.el,t=this.data;t.src&&t.apiKey&&(this.remove(),this.getGLTFUrl(t.src,t.apiKey).then(this.loadPolyModel).then(e=>{this.model=e.scene||e.scenes[0],this.model.animations=e.animations,o.setObject3D("mesh",this.model),t.normalize&&this.normalize(),o.emit("model-loaded")}).catch(e=>{console.error('ERROR loading Google Poly model from "'+t.src+'" : '+e),o.emit("model-error",e)}))},normalize:function(){const e=this.el,o=e.getObject3D("mesh"),t=new THREE.Vector3,r=new THREE.Vector3,n=new THREE.Vector3;r.copy(e.object3D.position),n.copy(e.object3D.scale),e.object3D.scale.set(1,1,1),e.object3D.position.set(0,0,0),e.object3D.updateMatrixWorld(!0);const i=new THREE.Box3;i.setFromObject(o);const s=new THREE.Sphere;i.getBoundingSphere(s);const a=s.center,c=s.radius,l=1*(0===c?1:1/c);o.traverse(e=>{e.isMesh&&(e.geometry.scale(l,l,l),e.geometry.translate(-l*a.x+t.x,-l*a.y+t.y,-l*a.z+t.z),e.geometry.computeBoundingBox(),e.geometry.computeBoundingSphere())}),e.object3D.scale.copy(n),e.object3D.position.copy(r),e.object3D.updateMatrixWorld(!0)},_remove:function(){this.model&&this.el.removeObject3D("mesh")},remove:function(){this._remove()},getGLTFUrl:function(e,o){const t="https://poly.googleapis.com/v1/assets/"+e+"/?key="+o;return getUrlPromise=fetch(t).then(function(o){return o.json().catch(e=>(console.log('ERROR parsing Google Poly API server response JSON.\nRequested Model: "'+t+'"\nError: "'+JSON.stringify(e)+'"'),Promise.reject("Google Poly API server error. Check console for details."))).then(o=>{if(void 0!==o.error)return Promise.reject("Poly API error: "+o.error.message);const t=o.formats.find(e=>"GLTF"===e.formatType||"GLTF2"===e.formatType);if(t){const e=o.presentationParams.orientingRotation,r=new THREE.Quaternion(e.x||0,e.y||0,e.z||0,e.w||1);return{url:t.root.url,quaternion:r}}return Promise.reject("Poly asset id:"+e+" not provided in GLTF2 format.")})})},loadPolyModel:function(e,o){const t=e.url,r=e.quaternion,n=(new THREE.Matrix4).makeRotationFromQuaternion(r);return new Promise((e,r)=>{const i=new THREE.FileLoader;i.setResponseType("arraybuffer"),i.load(t,o=>{try{const i=new THREE.GLTFLoader,s=THREE.LoaderUtils.extractUrlBase(t);i.parse(o,s,o=>{o.scene.traverse(function(e){e.geometry&&e.geometry.applyMatrix(n)}),e(o)},r)}catch(e){r(e.constructor===Error?e:new Error("THREE.GLTFLoader: Unable to parse model."))}},o,r)})}})}])});